#Include Swap.ahk2

SimpleCmp := (a, b) => (a < b ? -1 : b < a ? 1 : 0)

QuickSort(&arr, cmpFunc:="") {
	comparator := cmpFunc ? cmpFunc : SimpleCmp
    stack := []
    stack.Push([1, arr.Length])
    while(stack.Length != 0) {
        LR := stack.pop()
		L := LR[1]
		R := LR[2]
        if(R - L < 1)
            continue
        pivot := (L + R) // 2
        current := L
        new_pivot := L
        swapArr(&arr, pivot, R)
        while(current <= R) {
			if(current != new_pivot) {
				if(comparator.Call(arr[current], arr[R]) < 0) {
					swapArr(&arr, current, new_pivot)
					new_pivot += 1
				}
			}
            current += 1
		}
        swapArr(&arr, R, new_pivot)
        stack.Push([L, new_pivot - 1])
        stack.Push([new_pivot + 1, R])
	}
}

; Python program for implementation of MergeSort
; Merges two subarrays of arr[].
; First subarray is arr[l..m]
; Second subarray is arr[m+1..r]
merge(&arr, l, mid, r, cmp) {
    n1 := mid - l + 1
    n2 := r - mid
    LArray := [], LArray.Capacity := n1
    RArray := [], RArray.Capacity := n2
    ; Copy data to temp arrays L[] and R[]
    loop n1
        LArray.push(arr[A_Index + l])
    loop n2
        RArray.push(arr[A_Index + mid + 1])
    ; Merge the temp arrays back into arr[l..r]
    i := 1      ; Initial index of first subarray
    j := 1      ; Initial index of second subarray
    k := l + 1  ; Initial index of merged subarray
    while i <= n1 and j <= n2 {
        if cmp.Call(LArray[i], RArray[j]) < 0
            arr[k++] := LArray[i++]
        else
            arr[k++] := RArray[j++]
    }
    ; Copy the remaining elements of L[], if there
    ; are any
    while i <= n1
        arr[k++] := LArray[i++]
    ; Copy the remaining elements of R[], if there
    ; are any
    while j <= n2
        arr[k++] := RArray[j++]
}

; l is for left index and r is right index of the
; sub-array of arr to be sorted
mergeSort(&arr, l, r, cmp:="") {
    cmp := cmp ? cmp : SimpleCmp
    if l < r {
        ; Same as (l+r)//2, but avoids overflow for
        ; large l and h
        m := l + (r -  l) // 2
        ; Sort first and second halves
        mergeSort(&arr, l, m, cmp)
        mergeSort(&arr, m + 1, r, cmp)
        merge(&arr, l, m, r, cmp)
    }
}

; #SingleInstance Force
; SimpleCmp := (x,y) => x < y ? -1 : y < x ? 1 : 0
; CompareEdges := (a, b) => ((a[3] < b[3]) ? -1 : (b[3] < a[3]) ? 1 : 0)
; a := [
;     [2, 8, 5],
;     [8, 3, 2],
;     [0, 3, 8],
;     [5, 6, 9],
;     [0, 0, 1],
;     [0, 0, 0],
;     [0, 0, 3],
;     [0, 0, 7]
; ]
; mergeSort(&a, 0, a.Length - 1, CompareEdges)

; for key, val in a {
; 	out .= val[3] ","
; }
; MsgBox(out)

printIntArrayND(arr) {
	out.= "{"
	for key, val in arr {
		if(IsObject(val)) {
            if(Type(arr) = "Array" && A_Index < arr.Length
            || Type(val) = "Map" && A_Index < arr.Count) {
                out.= (Type(val) = "Map" ? "key = " : "")  "{" printIntArrayND(val) "}"
            }
        }
		else {
            out.= val
        }
        out.= ","
	}
	return out "}"
}
