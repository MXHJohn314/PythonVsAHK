;Assign04
ListLines(false)
#Warn All, Off


DllCall("QueryPerformanceFrequency", "Int64*", &frequency := 0)
CompareEdges := (a, b) => ((a[3] < b[3]) ? -1 : (b[3] < a[3]) ? 1 : 0)
CmpPointAB := (x, y) => x.a < y.b? -1 : x.a < y.b ? 1 : 0
reverseCmpEdge := (a, b) => ((a[3] > b[3]) ? -1 : (b[3] > a[3]) ? 1 : 0)
ONE_THOUSAND := Integer(10000000)

adjMatFromFile(filename) {
    ;Create an adj/weight matrix from a file with verts, neighbors, and weights.
	loop read filename {
		if(A_Index = 1) {
			n_verts := A_LoopReadLine
			adjmat := []
			loop n_verts {
				array := []
				loop n_verts
					array.Push("")
				adjmat.Push(array)
			}
			loop n_verts
				adjmat[A_Index][A_Index] := 0
		} else {
			int_list := []
			matches := StrSplit(A_LoopReadLine, A_Space)
			for i, s in matches
				if s != ""
					int_list.Push(s)
			vert := int_list.RemoveAt(1) + 1
			if(Mod(int_list.Length, 2) != 0)
				continue
			n_neighbors := Floor(int_list.Length / 2)
			neighbors := [], distances := []
			for i, value in int_list {
				if(Mod(i, 2) != 0)
					neighbors.Push(value + 1)
				else
					distances.Push(value)
			}
			loop n_neighbors
				adjmat[vert][neighbors[A_Index]] := distances[A_Index]
		}
	}
	for i, row in adjmat
		for j, val in row
			if adjmat[j][i] != val
				throw Error("invalid matrix. [" i ", " j "] has " (val ? val : "null") ", but [" j ", " i "] has " (adjmat[j][i] ? adjmat[j][i] : "null"))
	return adjmat
}

FindSets(MapOfSets, pointa, pointB) {
	for set, _ in MapOfSets{
		if InStr(set, pointa){
			s1 := set
			break
		}
	}
	for set, _ in MapOfSets{
		if InStr(set, pointB)
			return [s1, set]
	}
	
}

sortEdges(w) {
	t := Map()
	for i, row in w {
		for j, cost in row {
			if !cost
				continue
			if !t.Has(Chr(cost))
				t.Set(Chr(cost), [])
			t.Get(Chr(cost)).Push("|" i "|_|" j "|")
		}
	}
	return t
}

kruskal(w) {
    ;Carry out Kruskal's using W as a weight/adj matrix.
	global frequency
	e := 0
	start := 0
	DllCall("QueryPerformanceCounter", "Int64*", &start)
	solution := []
	sets := Map()
	loop w.Length
		sets.Set("|" A_Index "|", "")
	DllCall("QueryPerformanceCounter", "Int64*", &e := 0)
	t1 := e - start
	sorted := sortEdges(W)
	DllCall("QueryPerformanceCounter", "Int64*", &start)
	for c, edges in sorted {
		for _, ab in edges {
			f := StrSplit(ab, "_")
			setAB := FindSets(sets, f[1],  f[2])
			if setAB[1] = setAB[2]
				continue
			solution.Push({a: f[1], b:  f[2], cost: Ord(c)}),
			sets.Delete(setAB[1]),
			sets.Delete(setAB[2]),
			sets.Set(setAB[1] setAB[2], "")
		}
	}
	DllCall("QueryPerformanceCounter", "Int64*", &e := 0)
	t2 := e - start
	time := (t1 + t2)/frequency
	return {
		solution: solution,
		cost: CalcSum(solution),
		time: time
	}
}

prim(W) {
	global frequency
	DllCall("QueryPerformanceCounter", "Int64*", &s := 0)
    visited := "",
    solution := [],
    edgeMap := Map(),
	times := []
	list := []
    for i, row in W {
		for j, cost in row {
			if j != i && cost {
				c := Chr(cost)
				if edgeMap.Has(c)
					edgeMap.Get(c).push({a: "|" i "|" , b:  "|" j "|"})
				else {

					DllCall("QueryPerformanceCounter", "Int64*", &e := 0)
					times.Push(e - s)
					edgeMap.Set(c, [{a: "|" i "|" , b:  "|" j "|"}])
					DllCall("QueryPerformanceCounter", "Int64*", &s := 0)
				}

			}
		}
	}
	for key, edgeList in edgeMap {
		for _, verts in edgeList {
			visited .= verts.a verts.b,
			solution.Push({a: verts.a, b: verts.b, cost: Ord(key)}),
			edgeList.RemoveAt(1)
			break
		}
		break
	}
	i := 1
	while solution.Length < W.Length - 1 {
		outerBreak := false
		for cost, edges in edgeMap {
			c := Ord(cost)
			if edges.Length = 0 {
				edgeMap.Delete(cost)
				break
			}
			i := 1
			while i <= edges.Length {
				v := edges[i],
				contains1 := inStr(visited, v.a) > 0,
				contains2 := inStr(visited, v.b) > 0
				if contains1 && contains2 {
					edges.RemoveAt(i--)
				} else if contains1 {
					visited .= v.b,
					solution.push({a: v.a, b: v.b, cost: c})
					edges.RemoveAt(i),
					i := 0
					outerBreak := true
					break
				}
				i++
			}
			if solution.Length > W.Length - 1 {
				break
			}
			if  outerBreak {
				break
			}
		}
	}
	DllCall("QueryPerformanceCounter", "Int64*", &e := 0)
	totalTime := 0
	for t in times
		totalTime += t
    return {
		solution: solution,
		cost: CalcSum(solution),
		time: totalTime/frequency
	}
}

CalcSum(solution) {
	sum_ := 0
	for key, val in solution
		sum_ += val.cost
	return sum_
}

main(runCount){
	loop runCount {
		ToolTip(A_Index "/" runCount)
		FileAppend(run(), "ahk_results.txt")
	}
	; MsgBox(runs)
}
run(){
	reskrus25A := kruskal(adjMatFromFile("graph_verts25A.txt"))
	reskrus25B := kruskal(adjMatFromFile("graph_verts25B.txt"))
	reskrus50A := kruskal(adjMatFromFile("graph_verts50A.txt"))
	reskrus50B := kruskal(adjMatFromFile("graph_verts50B.txt"))
	reskrus100A := kruskal(adjMatFromFile("graph_verts100A.txt"))
	reskrus100B := kruskal(adjMatFromFile("graph_verts100B.txt"))
	reskrus250A := kruskal(adjMatFromFile("graph_verts250A.txt"))
	reskrus250B := kruskal(adjMatFromFile("graph_verts250B.txt"))
	reskrus500A := kruskal(adjMatFromFile("graph_verts500A.txt"))
	reskrus500B := kruskal(adjMatFromFile("graph_verts500B.txt"))
	resprim25B := kruskal(adjMatFromFile("graph_verts25B.txt"))
	
	resprim50A :=  prim(adjMatFromFile("graph_verts50A.txt"))
	resprim25A :=  prim(adjMatFromFile("graph_verts25A.txt"))
	resprim50B :=  prim(adjMatFromFile("graph_verts50B.txt"))
	resprim100A := prim(adjMatFromFile("graph_verts100A.txt"))
	resprim100B := prim(adjMatFromFile("graph_verts100B.txt"))
	resprim250A := prim(adjMatFromFile("graph_verts250A.txt"))
	resprim250B := prim(adjMatFromFile("graph_verts250B.txt"))
	resprim500A := prim(adjMatFromFile("graph_verts500A.txt"))
	resprim500B := prim(adjMatFromFile("graph_verts500B.txt"))
	resKrusSparse := [reskrus25A, reskrus50A, reskrus100A, reskrus250A, reskrus500A]
	resKrusDense := [reskrus25B, reskrus50B,reskrus100B, reskrus250B, reskrus500B]

	
	resPrimSparse := [resprim25A, resprim50A, resprim100A, resprim250A, resprim500A]
	resPrimDense := [resprim25B, resprim50B, resprim100B, resprim250B, resprim500B]

	return getResultString(
		Map(
			"krus", Map("sparse", resKrusSparse, "dense", resKrusDense),
			"prim", Map("sparse", resPrimSparse, "dense", resPrimDense)
		)	
	)
}

runAlgorithm(fileName, algo) {
	graph := adjMatFromFile(fileName)
	return algo.Call(graph)
}

getResultString(res) {
	s := "{"
	a := [25, 50, 100, 250, 500]
	for algName, version in res {
		s .= "`"" algName "`":{"
		for versionName, list in version {
			s .= "`"" versionName "`":["
			for i, value in list {
				s .= value.time  ","
			}
			s := SubStr(s, 1, -1) "],"
		}
		s := SubStr(s, 1, -1) "},"
	}
	return SubStr(s, 1, -1) "}`n"
}
main(100)
