;Assign04
ListLines(false)

CompareEdges := (a, b) => ((a[3] < b[3]) ? -1 : (b[3] < a[3]) ? 1 : 0)
CmpPointAB := (x, y) => x.a < y.b? -1 : x.a < y.b ? 1 : 0
reverseCmpEdge := (a, b) => ((a[3] > b[3]) ? -1 : (b[3] > a[3]) ? 1 : 0)
ONE_THOUSAND := Integer(10000000)

adjMatFromFile(filename) {
    ;Create an adj/weight matrix from a file with verts, neighbors, and weights.
	loop read filename {
		if(A_Index = 1) {
			n_verts := A_LoopReadLine
			adjmat := []
			loop n_verts {
				array := []
				loop n_verts
					array.Push("")
				adjmat.Push(array)
			}
			loop n_verts
				adjmat[A_Index][A_Index] := 0
		} else {
			int_list := []
			for _, s in StrSplit(A_LoopReadLine, " ")
				int_list.Push(s)
			vert := int_list.RemoveAt(1) + 1
			if(Mod(int_list.Length, 2) != 0)
				continue
			n_neighbors := Floor(int_list.Length / 2)
			neighbors := [], distances := []
			for i, value in int_list {
				if(Mod(i, 2) != 0)
					neighbors.Push(value + 1)
				else
					distances.Push(value)
			}
			loop n_neighbors
				adjmat[vert][neighbors[A_Index]] := distances[A_Index]
		}
	}
	return adjmat
}

FindSet(MapOfSets, point) {
	for set, _ in MapOfSets{
		if InStr(set, point)
			return set
	}
}

kruskal(w) {
    ;Carry out Kruskal's using W as a weight/adj matrix.
	DllCall("QueryPerformanceCounter", "Int64*", &start := 0)
    solution := []
	sets := Map()
	edges := []
	edges.Capacity := W.Length**2
	for i, row in w {
		sets.Set("|" i "|", "")
		for j, val in row {
			if val && i != j {
				cost := Integer(w[i][j])
				edge := {a: i, b: j, cost: cost}
				while edges.Length < cost {
					edges.Push("")
				}
				if !edges[cost]
					edges[cost] := [edge]
				else
					edges[cost].Push(edge)
			}
		}
	}
	cost := 1
	loop {
		while !edges[cost]
			cost++
		costEdges := edges[cost]
		for _, edge in costEdges {
			setA := FindSet(sets, edge.a)
			setB := FindSet(sets, edge.b)
			if(setA != setB) {
				solution.Push(edge)
				sets.Delete(setA)
				sets.Delete(setB)
				sets.Set(setA SetB, "")
			}
			if solution.Length = w.Length - 1
				break
		}
		cost++
		if solution.Length = w.Length - 1 || cost > edges.Length
			break
	}
	DllCall("QueryPerformanceCounter", "Int64*", &end := 0)
	return {
		solution: solution,
		cost: CalcSum(solution),
		time: (end - start)/ONE_THOUSAND
	}
}

prim(W) {
	DllCall("QueryPerformanceCounter", "Int64*", &start := 0)
    visited := "",
    solution := [],
    edgeMap := Map(),
	list := []
    for i, row in W {
		for j, cost in row {
			if j != i && cost {
				c := Chr(cost)
				if edgeMap.Has(c)
					edgeMap.Get(c).push({a: "|" i "|" , b:  "|" j "|"})
				else
					edgeMap.Set(c, [{a: "|" i "|" , b:  "|" j "|"}])
			}
		}
	}
	for key, edgeList in edgeMap {
		for _, verts in edgeList {
			visited .= verts.a verts.b,
			solution.Push({a: verts.a, b: verts.b, cost: Ord(key)}),
			edgeList.RemoveAt(1)
			break
		}
		break
	}
	i := 1
	while solution.Length < W.Length - 1 {
		outerBreak := false
		for cost, edges in edgeMap {
			c := Ord(cost)
			if edges.Length = 0 {
				edgeMap.Delete(cost)
				break
			}
			i := 1
			while i <= edges.Length {
				v := edges[i],
				contains1 := inStr(visited, v.a) > 0,
				contains2 := inStr(visited, v.b) > 0
				if contains1 && contains2 {
					edges.RemoveAt(i--)
				} else if contains1 {
					visited .= v.b,
					solution.push({a: v.a, b: v.b, cost: c})
					edges.RemoveAt(i),
					i := 0
					outerBreak := true
					break
				}
				i++
			}
			if solution.Length > W.Length - 1 {
				break
			}
			if  outerBreak {
				break
			}
		}
	}
	DllCall("QueryPerformanceCounter", "Int64*", &end := 0)
    return {
		solution: solution,
		cost: CalcSum(solution),
		time: (end - start)/ONE_THOUSAND
	}
}

CalcSum(solution) {
	sum_ := 0
	for key, val in solution
		sum_ += val.cost
	return sum_
}

graph_verts10 := adjMatFromFile("graph_verts10.txt")
graph_verts100A := adjMatFromFile("graph_verts100_A.txt")
graph_verts100B := adjMatFromFile("graph_verts100_B.txt")
res := {
	graph_verts10: {
		krus: kruskal(graph_verts10),
		prim: prim(graph_verts10)
	},
    graph_verts100A: {
		krus: kruskal(graph_verts100A),
		prim: prim(graph_verts100A)
	},
	graph_verts100B: {
		krus: kruskal(graph_verts100B),
		prim: prim(graph_verts100B)
	}
}

str := ""
. "`ngraph_verts10={"
. "`n krus={"
. "`n  cost= " res.graph_verts10.krus.cost ", sum= " res.graph_verts10.krus.cost ", time= " res.graph_verts10.krus.time ""
. "`n },"
. "`n prim={"
. "`n  cost= " res.graph_verts10.prim.cost ", sum= " res.graph_verts10.prim.cost ", time= " res.graph_verts10.prim.time ""
. "`n }"
. "`n},"
. "`ngraph_verts100A={"
. "`n krus={"
. "`n  cost= " res.graph_verts100A.krus.cost ", sum= " res.graph_verts100A.krus.cost ", time= " res.graph_verts100A.krus.time ""
. "`n },"
. "`n prim={"
. "`n  cost= " res.graph_verts100A.prim.cost ", sum= " res.graph_verts100A.prim.cost ", time= " res.graph_verts100A.prim.time ""
. "`n }"
. "`n},"
. "`ngraph_verts100B={"
. "`n krus={"
. "`n  cost= " res.graph_verts100B.krus.cost ", sum= " res.graph_verts100B.krus.cost ", time= " res.graph_verts100B.krus.time ""
. "`n },"
. "`n prim={"
. "`n  cost= " res.graph_verts100B.prim.cost ", sum= " res.graph_verts100B.prim.cost ", time= " res.graph_verts100B.prim.time ""
. "`n }"
. "`n},"


MsgBox(str)
